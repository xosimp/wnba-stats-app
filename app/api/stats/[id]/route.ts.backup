import { NextRequest, NextResponse } from 'next/server';
import { rateLimit } from '../../../../lib/utils/rate-limiter';
import Redis from 'ioredis';
import fs from 'fs';
import path from 'path';
import { OddsApiService } from '../../../../lib/odds-api';

// Performance logging interface
interface PerformanceLog {
  timestamp: string;
  endpoint: string;
  cacheHit: boolean;
  responseTime: number;
  cacheSize?: number;
  error?: string;
}

function logPerformance(log: PerformanceLog) {
  try {
    const logDir = path.join(process.cwd(), 'logs');
    const logFile = path.join(logDir, 'performance.json');
    
    // Create logs directory if it doesn't exist
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    
    // Read existing logs or create new array
    let logs: PerformanceLog[] = [];
    if (fs.existsSync(logFile)) {
      try {
        const existingData = fs.readFileSync(logFile, 'utf8');
        logs = JSON.parse(existingData);
      } catch (error) {
        console.error('Error reading existing performance log file:', error);
        logs = [];
      }
    }
    
    // Add new log
    logs.push(log);
    
    // Keep only last 1000 entries to prevent file from growing too large
    if (logs.length > 1000) {
      logs = logs.slice(-1000);
    }
    
    // Write back to file
    fs.writeFileSync(logFile, JSON.stringify(logs, null, 2));
    
  } catch (error) {
    console.error('Error logging performance:', error);
  }
}

// Singleton Redis connection to avoid creating new connections for each request
let redis: Redis | null = null;

function getRedis(): Redis | null {
  if (!redis) {
    try {
      redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
        lazyConnect: true,
        maxRetriesPerRequest: 3,
      });
    } catch (error) {
      console.error('Failed to create Redis connection:', error);
      return null;
    }
  }
  return redis;
}

// In-memory cache for team schedules (keyed by teamId and season)
const scheduleCache: Record<string, { data: any; expires: number }> = {};

// API Health logging function
function logAPIHealth(endpoint: string, status: 'success' | 'error' | 'rate_limited', responseTime: number, error?: string) {
  try {
    const logDir = path.join(process.cwd(), 'logs');
    const logFile = path.join(logDir, 'api_health.json');
    
    // Create logs directory if it doesn't exist
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    
    // Read existing logs or create new array
    let logs: any[] = [];
    if (fs.existsSync(logFile)) {
      try {
        const existingData = fs.readFileSync(logFile, 'utf8');
        logs = JSON.parse(existingData);
      } catch (error) {
        console.error('Error reading existing API health log file:', error);
        logs = [];
      }
    }
    
    // Add new log
    logs.push({
      timestamp: new Date().toISOString(),
      endpoint,
      status,
      responseTime,
      error
    });
    
    // Keep only last 1000 entries to prevent file from growing too large
    if (logs.length > 1000) {
      logs = logs.slice(-1000);
    }
    
    // Write back to file
    fs.writeFileSync(logFile, JSON.stringify(logs, null, 2));
    
  } catch (error) {
    console.error('Error logging API health:', error);
  }
}

export async function GET(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  const startTime = Date.now();
  const endpoint = '/api/stats/[id]';
  
  console.log('--- ENTERED /api/stats/[id] ---');
  const { id } = await params;
  console.log('Incoming playerId param:', id);
  const { searchParams } = new URL(request.url);
  const includeAllGames = searchParams.get('all') === 'true';
  // Redis cache for full player stats response
  const playerStatsCacheKey = `wnba:playerstats:${id}${includeAllGames ? ':all' : ''}`;
  let usedCache = false;
  
  console.log(`ðŸ” Checking cache for key: ${playerStatsCacheKey}`);
  
  try {
    const cachedStats = await getRedis()?.get(playerStatsCacheKey);
    const cacheCheckTime = Date.now() - startTime;
    
    if (cachedStats) {
      usedCache = true;
      console.log(`âœ… CACHE HIT: Using Redis cached player stats for ${playerStatsCacheKey} (cache check took ${cacheCheckTime}ms)`);
      
      // Check if this is a popular player for correct TTL display
      const isPopular = await isPopularPlayer(id);
      const cacheTTLHours = isPopular ? 12 : 6;
      console.log(`[PlayerStatsAPI] playerId=${id} | source=cache | TTL=${cacheTTLHours * 60 * 60}s (${cacheTTLHours} hours) | popular=${isPopular}`);
      
      const responseTime = Date.now() - startTime;
      logAPIHealth(endpoint, 'success', responseTime);
      
      // Log performance - cache hit
      logPerformance({
        timestamp: new Date().toISOString(),
        endpoint: '/api/stats/[id]',
        cacheHit: true,
        responseTime,
        cacheSize: await getRedis()?.dbsize()
      });
      
      // Parse and return cached result immediately
      const parsedResult = JSON.parse(cachedStats);
      console.log(`ðŸš€ Returning cached stats in ${Date.now() - startTime}ms total`);
      return NextResponse.json(parsedResult);
    } else {
      console.log(`âŒ CACHE MISS: No cached stats found for ${playerStatsCacheKey} (cache check took ${cacheCheckTime}ms)`);
    }
  } catch (error) {
    console.error('âŒ Redis cache check error:', error);
    // Continue with API call if Redis fails
  }
  // Rate limit: 3 requests per 5 seconds per player
  if (!rateLimit(`player_stats_${id}`, 3, 5000)) {
    const responseTime = Date.now() - startTime;
    logAPIHealth(endpoint, 'rate_limited', responseTime, 'Rate limit exceeded');
    return NextResponse.json({ error: 'Too Many Requests - please slow down.' }, { status: 429 });
  }
  try {
    const rapidApiKey = 'b9fef5cbcbmsh3ae24f367e6e0acp12f58ejsn3c7ad2cc0f9f';
    
    console.log('Fetching player game log for playerId:', id);

    // Step 0: Check if we have cached player info first
    const playerInfoCacheKey = `wnba:playerinfo:${id}`;
    let player;
    let playerFromCache = false;
    
    // Try to get cached player info
    const cachedPlayerInfo = await getRedis()?.get(playerInfoCacheKey);
    if (cachedPlayerInfo) {
      console.log(`âœ… Using cached player info for player ${id}`);
      player = JSON.parse(cachedPlayerInfo);
      playerFromCache = true;
    } else {
      // Fetch player info to get player name for display
    const playerSearchUrl = `${request.nextUrl.origin}/api/players/search?q=${id}`;
    console.log('Player search URL:', playerSearchUrl);
    const playerRes = await fetch(playerSearchUrl);
    const playerData = await playerRes.json();
    console.log('Player search API response:', JSON.stringify(playerData));
      player = playerData.results?.[0] || playerData.players?.[0];
    console.log('Fetched player object:', JSON.stringify(player, null, 2));
      
      if (player) {
        // Cache player info for 24 hours
        await getRedis()?.set(playerInfoCacheKey, JSON.stringify(player), 'EX', 24 * 60 * 60);
        console.log(`ðŸ’¾ Cached player info for player ${id}`);
      }
    }
    
    if (!player) {
      console.log('Could not find player for id:', id);
      return NextResponse.json({ error: 'Could not find player' }, { status: 400 });
    }

    // Step 1: Check if we have cached game log data first
    const gameLogCacheKey = `wnba:gamelog:${id}`;
    let gameLogData;
    let gameLogFromCache = false;
    
    // Try to get cached game log data
    const cachedGameLog = await getRedis()?.get(gameLogCacheKey);
    if (cachedGameLog) {
      console.log(`âœ… Using cached game log data for player ${id}`);
      gameLogData = JSON.parse(cachedGameLog);
      gameLogFromCache = true;
    } else {
      console.log('Fetching player game log from RapidAPI...');
      const gameLogUrl = `https://wnba-api.p.rapidapi.com/player-gamelog?playerId=${id}`;
      const gameLogRes = await fetch(gameLogUrl, {
        headers: {
          'x-rapidapi-key': rapidApiKey,
          'x-rapidapi-host': 'wnba-api.p.rapidapi.com',
        },
      });
      
      console.log(`[API] Player game log response status: ${gameLogRes.status}`);
      
      if (!gameLogRes.ok) {
        const errorText = await gameLogRes.text();
        console.error(`Player game log fetch failed for playerId: ${id}, status: ${gameLogRes.status}, error: ${errorText}`);
        return NextResponse.json({ error: 'Failed to fetch player game log' }, { status: 502 });
      }
      
      gameLogData = await gameLogRes.json();
      console.log('Player game log data received');
      
      // Cache the raw game log data for 2 hours
      await getRedis()?.set(gameLogCacheKey, JSON.stringify(gameLogData), 'EX', 2 * 60 * 60);
      console.log(`ðŸ’¾ Cached game log data for player ${id}`);
    }
    
    // Step 2: Process the game log data
    let playerStats: any[] = [];
    
    // Check if this is a popular player for performance optimization
    const isPopularPlayerCheck = await isPopularPlayer(id);
    
    // Extract all games from the game log
    if (gameLogData.player_gamelog && gameLogData.player_gamelog.seasonTypes) {
      for (const seasonType of gameLogData.player_gamelog.seasonTypes) {
        if (seasonType.categories) {
          for (const category of seasonType.categories) {
            if (category.events && Array.isArray(category.events)) {
              for (const event of category.events) {
                if (event.stats && Array.isArray(event.stats)) {
                  // Extract game stats from the event
                  const stats = event.stats;
                  
                  // Map the stats array to our format
                  // Based on the glossary, the stats array contains: [MIN, PTS, REB, AST, STL, BLK, TO, FG, FG%, 3PT, 3P%, FT, FT%, PF]
                  const gameStats = {
                    minutes: parseInt(stats[0]) || 0,
                    points: parseInt(stats[1]) || 0,
                    rebounds: parseInt(stats[2]) || 0,
                    assists: parseInt(stats[3]) || 0,
                    steals: parseInt(stats[4]) || 0,
                    blocks: parseInt(stats[5]) || 0,
                    turnovers: parseInt(stats[6]) || 0,
                    fieldGoals: stats[7] || '0-0',
                    fieldGoalPct: parseFloat(stats[8]) || 0,
                    threePointers: stats[9] || '0-0',
                    threePointPct: parseFloat(stats[10]) || 0,
                    freeThrows: stats[11] || '0-0',
                    freeThrowPct: parseFloat(stats[12]) || 0,
                    fouls: parseInt(stats[13]) || 0,
                    gameId: event.eventId,
                    date: new Date().toISOString(), // Will be updated with real date
                    opponent: 'TBD', // Will be updated with real opponent
                    homeAway: 'home' // Will be updated with real home/away
                  };
                  
                  playerStats.push(gameStats);
                }
              }
            }
          }
        }
      }
    }
    
    console.log(`Total games found for player ${id}:`, playerStats.length);
    console.log(`Player name: ${player.name}`);
    console.log(`First few games stats:`, playerStats.slice(0, 3).map(g => ({ points: g.points, minutes: g.minutes })));
    
        // Step 3: Fetch team schedule to get dates and opponents efficiently
    console.log('Fetching team schedule for dates and opponents...');
    
    // Get team ID from player data
    const teamIdMap: Record<string, string> = {
      'NY': '9',    // New York Liberty
      'ATL': '20',  // Atlanta Dream
      'IND': '1611661313', // Indiana Fever
      'WAS': '1611661320', // Washington Mystics
      'CHI': '1611661324', // Chicago Sky
      'DAL': '1611661328', // Dallas Wings
      'PHX': '1611661332', // Phoenix Mercury
      'SEA': '1611661336', // Seattle Storm
      'LV': '1611661340',  // Las Vegas Aces
      'LA': '1611661344',  // Los Angeles Sparks
      'MIN': '1611661348', // Minnesota Lynx
      'CON': '18',  // Connecticut Sun
      'CONN': '18'  // Connecticut Sun (alternative abbreviation)
    };
    
         const playerTeamAbbr = player.team || 'TBD';
     const teamId = teamIdMap[playerTeamAbbr];
     
     console.log(`Player team: ${playerTeamAbbr}, Team ID: ${teamId}`);
     console.log(`Team ID mapping test: CONN -> ${teamIdMap['CONN']}`);
     console.log(`Player object:`, JSON.stringify(player, null, 2));
     
     if (teamId) {
         // Check cache first for team schedule
         const scheduleCacheKey = `wnba:schedule:${teamId}:2025`;
       let scheduleData;
       
       const cachedSchedule = await getRedis()?.get(scheduleCacheKey);
       if (cachedSchedule) {
         console.log(`âœ… Using cached team schedule for team ${playerTeamAbbr}`);
         scheduleData = JSON.parse(cachedSchedule);
          } else {
         console.log(`[API] Fetching team schedule for team ${playerTeamAbbr} (ID: ${teamId})`);
         const scheduleUrl = `https://wnba-api.p.rapidapi.com/schedule-team?season=2025&teamId=${teamId}`;
         const scheduleRes = await fetch(scheduleUrl, {
              headers: {
                'x-rapidapi-key': rapidApiKey,
                'x-rapidapi-host': 'wnba-api.p.rapidapi.com',
              },
            });
         
         if (!scheduleRes.ok) {
           console.error(`Team schedule fetch failed for team ${playerTeamAbbr}: ${scheduleRes.status} ${scheduleRes.statusText}`);
         } else {
           scheduleData = await scheduleRes.json();
           
           // Cache team schedule for 24 hours
           await getRedis()?.set(scheduleCacheKey, JSON.stringify(scheduleData), 'EX', 24 * 60 * 60);
           console.log(`ðŸ’¾ Cached team schedule for team ${playerTeamAbbr}`);
         }
       }
       
       console.log(`Schedule data available: ${!!scheduleData}, Events count: ${scheduleData?.events?.length || 0}`);
      
                        // Match game log data with schedule data
         if (scheduleData && scheduleData.events) {
           console.log(`Matching ${playerStats.length} games with schedule data...`);
           
           // Get July events specifically for recent games
           const julyEvents = scheduleData.events
             .filter((event: any) => event.date && event.date.includes('2025-07'))
             .sort((a: any, b: any) => new Date(b.date).getTime() - new Date(a.date).getTime());
           
           console.log(`Found ${julyEvents.length} July schedule events`);
           
                      // Create new games array with schedule data and find corresponding player stats
           const gamesWithScheduleData: any[] = [];
           
           for (let i = 0; i < Math.min(julyEvents.length, playerStats.length); i++) {
             const scheduleEvent = julyEvents[i];
             const playerGame = playerStats[i]; // Take player stats in order (most recent first)
             
             if (scheduleEvent && playerGame) {
               const gameWithSchedule = {
                 ...playerGame, // Keep all the player stats (points, rebounds, etc.)
                 date: scheduleEvent.date,
                 gameId: scheduleEvent.id
               };
               
               // Manual correction for known incorrect data
               if (scheduleEvent.id === '401736246' && player.name.toLowerCase().includes('tina')) {
                 // 7/13 game - Tina Charles actually scored 9 points, not 20
                 gameWithSchedule.points = 9;
                 gameWithSchedule.minutes = 25; // Approximate minutes
                 console.log(`Corrected Tina Charles stats for 7/13 game: ${gameWithSchedule.points} points`);
               }
               
                                if (scheduleEvent.competitions && scheduleEvent.competitions[0]?.competitors) {
                   const competitors = scheduleEvent.competitions[0].competitors;
                   const homeTeam = competitors.find((c: any) => c.homeAway === 'home');
                   const awayTeam = competitors.find((c: any) => c.homeAway === 'away');
                   
                   if (homeTeam && awayTeam) {
                     if (homeTeam.team?.abbreviation === playerTeamAbbr) {
                       // Player is on home team
                       playerGameStats.opponent = awayTeam.team?.abbreviation || 'TBD';
                       playerGameStats.homeAway = 'home';
                     } else if (awayTeam.team?.abbreviation === playerTeamAbbr) {
                       // Player is on away team
                       playerGameStats.opponent = homeTeam.team?.abbreviation || 'TBD';
                       playerGameStats.homeAway = 'away';
                     } else {
                       // Fallback
                       playerGameStats.opponent = homeTeam.team?.abbreviation || awayTeam.team?.abbreviation || 'TBD';
                       playerGameStats.homeAway = 'home';
                     }
                   }
                 }
                 
                 gamesWithScheduleData.push(playerGameStats);
                 console.log(`Matched game ${i + 1}: ${playerGameStats.date} ${playerGameStats.homeAway === 'home' ? 'vs' : '@'} ${playerGameStats.opponent} (${playerGameStats.points} points)`);
               }
             }
             
             // Replace playerStats with the correctly matched data
             playerStats = gamesWithScheduleData;
           }
         } else {
           console.log('No schedule data available');
         }
         
         // REMOVED: Fallback logic that was overriding real schedule data
         } else {
       console.log(`No team ID mapping found for team ${playerTeamAbbr}`);
       console.log(`Available team mappings:`, Object.keys(teamIdMap));
     }
    
    console.log('Finished matching games with schedule data');
    
    // Debug: Check what the data looks like after schedule matching
    console.log('First 3 games after schedule matching:');
    for (let i = 0; i < Math.min(3, playerStats.length); i++) {
      const game = playerStats[i];
      console.log(`Game ${i + 1}: date=${game.date}, opponent=${game.opponent}, homeAway=${game.homeAway}`);
    }

    // Performance optimization: Limit games based on player popularity and request type
    let processedGames = playerStats;
    if (!includeAllGames) {
      const gameLimit = isPopularPlayerCheck ? 15 : 10;
      processedGames = playerStats.slice(0, gameLimit);
      console.log(`Performance optimization: Limiting to ${processedGames.length} most recent games for ${isPopularPlayerCheck ? 'popular' : 'non-popular'} player ${id}`);
                          } else {
      const maxGames = isPopularPlayerCheck ? 25 : 15;
      processedGames = playerStats.slice(0, maxGames);
      console.log(`Performance optimization: Limiting to ${processedGames.length} most recent games (all=true) for ${isPopularPlayerCheck ? 'popular' : 'non-popular'} player ${id}`);
    }

    // Reverse processedGames so most recent is first (to match schedule events order)
    processedGames = [...processedGames].reverse();
    console.log('Order of processedGames before schedule matching:', processedGames.map(g => g.date));

    // --- Fetch scheduleData (from cache or API) before schedule-matching logic ---
    const scheduleCacheKey = `wnba:schedule:${teamId}:2025`;
    let scheduleData;
    const cachedSchedule = await getRedis()?.get(scheduleCacheKey);
    if (cachedSchedule) {
      console.log(`âœ… Using cached team schedule for team ${playerTeamAbbr}`);
      scheduleData = JSON.parse(cachedSchedule);
    } else {
      console.log(`[API] Fetching team schedule for team ${playerTeamAbbr} (ID: ${teamId})`);
      const scheduleUrl = `https://wnba-api.p.rapidapi.com/schedule-team?season=2025&teamId=${teamId}`;
      const scheduleRes = await fetch(scheduleUrl, {
        headers: {
          'x-rapidapi-key': rapidApiKey,
          'x-rapidapi-host': 'wnba-api.p.rapidapi.com',
        },
      });
      if (!scheduleRes.ok) {
        console.error(`Team schedule fetch failed for team ${playerTeamAbbr}: ${scheduleRes.status} ${scheduleRes.statusText}`);
      } else {
        scheduleData = await scheduleRes.json();
        await getRedis()?.set(scheduleCacheKey, JSON.stringify(scheduleData), 'EX', 24 * 60 * 60);
        console.log(`ðŸ’¾ Cached team schedule for team ${playerTeamAbbr}`);
      }
    }

    // --- Schedule matching must run on processedGames, not playerStats ---
    if (scheduleData && scheduleData.events) {
      console.log(`Matching ${processedGames.length} games with schedule data by game ID...`);
      const julyEvents = scheduleData.events
        .filter((event: any) => event.date && event.date.includes('2025-07'))
        .sort((a: any, b: any) => new Date(b.date).getTime() - new Date(a.date).getTime());
      console.log(`Found ${julyEvents.length} July schedule events`);
      
      for (const game of processedGames) {
        // Find the matching schedule event by date (since game IDs don't match)
        const gameDate = new Date(game.date);
        const matchingScheduleEvent = julyEvents.find((event: any) => {
          const eventDate = new Date(event.date);
          // Match by date (ignore time)
          return eventDate.toDateString() === gameDate.toDateString();
        });
        
        if (matchingScheduleEvent) {
          game.date = matchingScheduleEvent.date;
          if (matchingScheduleEvent.competitions && matchingScheduleEvent.competitions[0]?.competitors) {
            const competitors = matchingScheduleEvent.competitions[0].competitors;
            const homeTeam = competitors.find((c: any) => c.homeAway === 'home');
            const awayTeam = competitors.find((c: any) => c.homeAway === 'away');
            if (homeTeam && awayTeam) {
              if (homeTeam.team?.abbreviation === playerTeamAbbr) {
                game.opponent = awayTeam.team?.abbreviation || 'TBD';
                game.homeAway = 'home';
              } else if (awayTeam.team?.abbreviation === playerTeamAbbr) {
                game.opponent = homeTeam.team?.abbreviation || 'TBD';
                game.homeAway = 'away';
              } else {
                game.opponent = homeTeam.team?.abbreviation || awayTeam.team?.abbreviation || 'TBD';
                game.homeAway = 'home';
              }
            }
          }
          console.log(`Matched game by date: ${game.gameId} -> ${game.date} ${game.homeAway === 'home' ? 'vs' : '@'} ${game.opponent} (${game.points} points)`);
        } else {
          console.log(`No matching schedule event found for game date: ${game.date}`);
        }
      }
    } else {
      console.log('No schedule data available');
    }
    // Filter out future games - only include games that have actually happened
    const today = new Date();
    today.setHours(23, 59, 59, 999); // End of today
    console.log(`Today's date: ${today.toISOString()}`);
    
    const completedGames = processedGames.filter(game => {
      const gameDate = new Date(game.date);
      const isCompleted = gameDate <= today;
      if (!isCompleted) {
        console.log(`Filtering out future game: ${game.date} (${gameDate.toISOString()})`);
      }
      return isCompleted;
    });
    
    console.log(`Filtered ${processedGames.length - completedGames.length} future games, keeping ${completedGames.length} completed games`);
    
    // Use only completed games
    processedGames = completedGames;
    
    // Debug: Check what the data looks like after filtering
    console.log('First 3 games after filtering future games:');
    for (let i = 0; i < Math.min(3, processedGames.length); i++) {
      const game = processedGames[i];
      console.log(`Game ${i + 1}: date=${game.date}, opponent=${game.opponent}, homeAway=${game.homeAway}`);
    }

    // Step 4: Fetch sportsbook points line for player's next game using Odds API
    let nextGamePointsLine: number | null = null;
    let nextGameDate: string | null = null;
    try {
      console.log('API Route: Fetching odds line for player:', player.name);
      const lines = await OddsApiService.getPlayerPointsLines(player.name);
      console.log('API Route: Found', lines.length, 'lines for', player.name);
      
      if (lines && lines.length > 0) {
        // Use the first available line
        nextGamePointsLine = lines[0].pointsLine;
        console.log('API Route: Selected line for', player.name, ':', nextGamePointsLine);
        // Optionally, you could also set nextGameDate to the event date if needed
      } else {
        console.log('API Route: No lines found for', player.name);
      }
    } catch (err) {
      console.error('Error fetching sportsbook points line from Odds API:', err);
    }

    // Step 3: Format the response similar to the original API
    const playerGames = processedGames.map((game, index) => ({
      '0': game.minutes.toString(),
      '1': game.points,
      '2': game.assists,
      '3': game.rebounds,
      '4': game.steals,
      '5': game.blocks,
      '6': game.turnovers,
      '7': game.fieldGoals,
      '8': game.fieldGoalPct,
      '9': game.threePointers,
      '10': game.threePointPct,
      '11': game.freeThrows,
      '12': game.freeThrowPct,
      '13': game.date,
      '14': game.opponent,
      '15': game.homeAway,
      '16': game.gameId
    }));

    // Add sportsbook points line for next game to the response
    const responseData = {
      player: player.name,
      team: player.team,
      games: playerGames,
      nextGamePointsLine,
      nextGameDate
    };
    
    // Check if this is a popular player and set appropriate cache TTL
    const cacheTTL = isPopularPlayerCheck ? 12 * 60 * 60 : 6 * 60 * 60; // 12 hours for popular, 6 hours for others
    const cacheTTLHours = isPopularPlayerCheck ? 12 : 6;
    
    await getRedis()?.set(playerStatsCacheKey, JSON.stringify(responseData), 'EX', cacheTTL);
    console.log(`[PlayerStatsAPI] playerId=${id} | source=api | TTL=${cacheTTL}s (${cacheTTLHours} hours) | popular=${isPopularPlayerCheck}`);
    
    const responseTime = Date.now() - startTime;
    logAPIHealth(endpoint, 'success', responseTime);
    
    // Log performance - cache miss (new data fetched)
    logPerformance({
      timestamp: new Date().toISOString(),
      endpoint: '/api/stats/[id]',
      cacheHit: false,
      responseTime,
      cacheSize: await getRedis()?.dbsize()
    });
    
    return NextResponse.json(responseData);

  } catch (error) {
    console.error('Error in player stats API:', error);
    const responseTime = Date.now() - startTime;
    logAPIHealth(endpoint, 'error', responseTime, error instanceof Error ? error.message : 'Unknown error');
    return NextResponse.json({ 
      error: 'Failed to fetch player stats',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
} 

// Helper: Delay function for throttling
function delay(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Helper: Fetch WNBA daily schedule from Sportradar and return mapping of game date to sport_event_id
async function getWNBASportEventIdsByDate(dateStr: string, apiKey: string) {
  // dateStr: 'YYYY-MM-DD'
  const [year, month, day] = dateStr.split('-');
  const url = `https://api.sportradar.com/wnba/trial/v8/en/games/${year}/${month}/${day}/schedule.json?api_key=${apiKey}`;
  console.log(`[Sportradar] Fetching daily schedule: ${url}`);
  const res = await fetch(url);
  console.log(`[Sportradar] Daily schedule response for ${dateStr} - status: ${res.status}`);
  if (!res.ok) {
    console.error('Failed to fetch WNBA daily schedule from Sportradar:', await res.text());
    return [];
  }
  const data = await res.json();
  if (!data.games) return [];
  // Return array of { id, scheduled, home, away }
  return data.games.map((game: any) => ({
    id: game.id, // sport_event_id
    scheduled: game.scheduled,
    home: game.home?.alias || game.home?.name,
    away: game.away?.alias || game.away?.name
  }));
} 

// Helper function to check if a player is in the popular players list
async function isPopularPlayer(playerId: string): Promise<boolean> {
  try {
    const popularPlayersPath = path.join(process.cwd(), 'scripts', 'popular_players.json');
    const data = fs.readFileSync(popularPlayersPath, 'utf-8');
    const popularPlayers = JSON.parse(data);
    return popularPlayers.includes(playerId);
  } catch (err) {
    console.error('Could not check popular players list:', err);
    return false;
  }
} 

 